import math

# CORRECTED COORDINATE SYSTEM (Generated by coordinate_system_fixer.py)

class CorrectedCoordinateSystem:
    """Corrected coordinate system with accurate kinematics."""
    
    def __init__(self):
        # TODO: HARDCODE REMOVAL - Canvas parameters should come from config
        # Current: Hardcoded values everywhere
        # Future: def __init__(self, config): self.canvas_position = config['canvas']['position']
        self.canvas_position = [0.6, 0.0, 0.05]  # HARDCODE: Should be from config
        self.canvas_size = 0.4                   # HARDCODE: Should be from config
        self.pixel_width = 800                   # HARDCODE: Should be from config
        self.pixel_height = 600                  # HARDCODE: Should be from config
        
        # TODO: HARDCODE REMOVAL - UR5e parameters should come from robot spec config
        self.base_height = 0.163      # HARDCODE: UR5e spec
        self.shoulder_offset = 0.138  # HARDCODE: UR5e spec  
        self.upper_arm = 0.425        # HARDCODE: UR5e spec
        self.forearm = 0.392          # HARDCODE: UR5e spec
        
    def pixel_to_robot_coords(self, pixel_x, pixel_y, pen_down=True):
        """Convert pixel coordinates to robot coordinates."""
        # Use same scale for both X and Y to maintain circle proportions
        scale = self.canvas_size / self.pixel_width
        
        canvas_x = (pixel_x - self.pixel_width / 2) * scale
        canvas_y = (pixel_y - self.pixel_height / 2) * scale
        
        robot_x = self.canvas_position[0] + canvas_x
        robot_y = self.canvas_position[1] + canvas_y
        # TODO: HARDCODE REMOVAL - Pen heights should be configurable
        robot_z = self.canvas_position[2] + (0.02 if pen_down else 0.05)  # HARDCODE: pen heights
        
        return robot_x, robot_y, robot_z
        
    def robot_coords_to_joints(self, robot_x, robot_y, robot_z, base_joints):
        """Convert robot coordinates to joint positions using inverse kinematics."""
        # Calculate base rotation
        target_pan = math.atan2(robot_y - self.shoulder_offset, robot_x)
        
        # Calculate distance and angles
        dx = robot_x - 0
        dy = robot_y - self.shoulder_offset
        horizontal_distance = math.sqrt(dx*dx + dy*dy)
        dz = robot_z - self.base_height
        target_distance = math.sqrt(horizontal_distance*horizontal_distance + dz*dz)
        
        # 2-link inverse kinematics
        max_reach = self.upper_arm + self.forearm
        if target_distance > max_reach:
            target_distance = max_reach * 0.95
            
        cos_shoulder = (self.upper_arm**2 + target_distance**2 - self.forearm**2) / (2 * self.upper_arm * target_distance)
        cos_shoulder = max(-1, min(1, cos_shoulder))
        
        angle_to_target = math.atan2(dz, horizontal_distance)
        shoulder_angle = angle_to_target - math.acos(cos_shoulder)
        
        cos_elbow = (self.upper_arm**2 + self.forearm**2 - target_distance**2) / (2 * self.upper_arm * self.forearm)
        cos_elbow = max(-1, min(1, cos_elbow))
        elbow_angle = math.pi - math.acos(cos_elbow)
        
        joints = base_joints.copy()
        joints[0] = target_pan
        joints[1] = shoulder_angle
        joints[2] = elbow_angle
        
        return joints
        
    def joints_to_robot_position(self, joints):
        """Forward kinematics: convert joint positions to robot position."""
        q1, q2, q3 = joints[0], joints[1], joints[2]
        
        c1, s1 = math.cos(q1), math.sin(q1)
        
        # Position after upper arm
        upper_end_x = self.upper_arm * math.cos(q2) * c1
        upper_end_y = self.shoulder_offset + self.upper_arm * math.cos(q2) * s1
        upper_end_z = self.base_height + self.upper_arm * math.sin(q2)
        
        # Position after forearm
        forearm_angle = q2 + q3
        end_x = upper_end_x + self.forearm * math.cos(forearm_angle) * c1
        end_y = upper_end_y + self.forearm * math.cos(forearm_angle) * s1
        end_z = upper_end_z + self.forearm * math.sin(forearm_angle)
        
        return (end_x, end_y, end_z)
    
    def joints_to_tool_flange_position(self, joints):
        """Convert joint positions to tool flange position (tool0 frame)."""
        # First get wrist_3 position (end-effector)
        wrist3_pos = self.joints_to_robot_position(joints)
        
        # TODO: HARDCODE REMOVAL - UR5e tool flange offset should be in robot specs
        # UR5e tool flange is 82.5mm from wrist_3 along the Z-axis
        # With current joint configuration, tool flange extends toward canvas
        flange_offset = 0.0825  # HARDCODE: UR5e spec - 82.5mm
        
        # Calculate tool flange position
        # For UR5e, tool flange extends along wrist_3 Z-axis
        # Joint 4 (wrist_2) affects the tool orientation
        q4 = joints[4]  # wrist_2_joint
        q5 = joints[5]  # wrist_3_joint
        
        # Tool flange offset in base frame coordinates
        # Simplified: assume tool points in same direction as wrist_3
        flange_x = wrist3_pos[0]
        flange_y = wrist3_pos[1] 
        flange_z = wrist3_pos[2] - flange_offset  # Tool flange is below wrist_3
        
        return (flange_x, flange_y, flange_z)
    
    def joints_to_pen_tip_position(self, joints):
        """Convert joint positions to actual pen tip position."""
        # First get tool flange position
        flange_pos = self.joints_to_tool_flange_position(joints)
        
        # TODO: HARDCODE REMOVAL - Pen specifications should match config.yaml
        # Current: 30cm realistic pen (confirmed working after 1m test)
        # Future: total_pen_extension = config['pen']['tip_offset']
        # CRITICAL: This MUST match config.yaml pen.tip_offset value exactly!
        total_pen_extension = 1.0  # HARDCODE: 復旧 - 1m pen that was working
        
        # Calculate pen tip position
        # BUG FIX: tool flangeからwrist3の逆方向（さらに下方向）にペンを延ばす
        # wrist3 → tool_flange(下82.5mm) → pen_tip(さらに下200mm)
        # つまり、tool flangeからさらに下方向にペンが延びる
        tip_x = flange_pos[0]
        tip_y = flange_pos[1]
        tip_z = flange_pos[2] - total_pen_extension  # tool flangeからさらに下方向
        
        return (tip_x, tip_y, tip_z)
        
    def robot_to_pixel_coords(self, robot_x, robot_y):
        """Convert robot coordinates back to pixel coordinates."""
        # Use same scale for both X and Y to maintain circle proportions
        scale = self.canvas_size / self.pixel_width
        
        # Transform from robot to canvas coordinate system
        canvas_x = robot_x - self.canvas_position[0]
        canvas_y = robot_y - self.canvas_position[1]
        
        # Convert canvas coordinates to pixel coordinates
        pixel_x = canvas_x / scale + self.pixel_width / 2
        pixel_y = canvas_y / scale + self.pixel_height / 2
        
        return pixel_x, pixel_y

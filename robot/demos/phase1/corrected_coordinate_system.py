import math

# CORRECTED COORDINATE SYSTEM (Generated by coordinate_system_fixer.py)
# TODO: TF2を利用した座標系の管理システムへの移行

class CorrectedCoordinateSystem:
    """Corrected coordinate system with accurate kinematics."""
    
    def __init__(self, config=None):
        # Load configuration file.
        if config is None:
            raise ValueError("❌ Configuration is required for CorrectedCoordinateSystem")
        
        # Canvas parameters from config
        canvas_config = config['canvas']
        self.canvas_position = canvas_config['position']
        self.canvas_size = canvas_config['physical_size']
        self.pixel_width = canvas_config['pixel_width']
        self.pixel_height = canvas_config['pixel_height']
        self.contact_height = canvas_config['contact_height']
        self.safe_height = canvas_config['safe_height']
        
        # Pen parameters from config
        pen_config = config['pen']
        self.pen_length = pen_config['length']

        # TODO: HARDCODE REMOVAL - UR5e parameters should come from robot spec config
        self.base_height = 0.163      # HARDCODE: UR5e spec
        self.shoulder_offset = 0.138  # HARDCODE: UR5e spec  
        self.upper_arm = 0.425        # HARDCODE: UR5e spec
        self.forearm = 0.392          # HARDCODE: UR5e spec
        
    def pixel_to_robot_coords(self, pixel_x, pixel_y, pen_down=True):
        """
        Convert pixel coordinates on canvas to robot coordinates.

        Input:
        - pixel_x: X coordinate in "pixel frame"
        - pixel_y: Y coordinate in "pixel frame"
        - pen_down: True if pen is down, False if pen is up
        Output:
        - (robot_x, robot_y, robot_z): Robot coordinates in "robot base frame"
        """
        # Use same scale for both X and Y to maintain circle proportions
        # TODO: remove pixel coordinates dependency
        # TODO: use TF2 system for coordinate transformations
        scale = self.canvas_size / self.pixel_width
        
        canvas_x = (pixel_x - self.pixel_width / 2) * scale
        canvas_y = (pixel_y - self.pixel_height / 2) * scale
        
        robot_x = self.canvas_position[0] + canvas_x
        robot_y = self.canvas_position[1] + canvas_y
        
        robot_z = self.canvas_position[2] + (self.contact_height if pen_down else self.safe_height)
        
        return robot_x, robot_y, robot_z
        
    def wrist3_coords_to_joints(self, wrist3_x, wrist3_y, wrist3_z, base_joints):
        """
        Convert wrist3 coordinates to joint positions using inverse kinematics.
        Input:
        - wrist3_x: X coordinate of wrist3 in "robot base frame"
        - wrist3_y: Y coordinate of wrist3 in "robot base frame"
        - wrist3_z: Z coordinate of wrist3 in "robot base frame"
        - base_joints: Current joint positions (base, shoulder, elbow, wrist1, wrist2, wrist3): angles in radians
        Output:
        - joints: New joint positions (base, shoulder, elbow) in "robot base frame"
        """
        # Calculate base rotation
        target_pan = math.atan2(wrist3_y - self.shoulder_offset, wrist3_x)
        
        # Calculate distance and angles
        dx = wrist3_x - 0
        dy = wrist3_y - self.shoulder_offset
        horizontal_distance = math.sqrt(dx*dx + dy*dy)
        dz = wrist3_z - self.base_height
        target_distance = math.sqrt(horizontal_distance*horizontal_distance + dz*dz)
        
        # 2-link inverse kinematics
        max_reach = self.upper_arm + self.forearm
        if target_distance > max_reach:
            target_distance = max_reach * 0.95
            
        cos_shoulder = (self.upper_arm**2 + target_distance**2 - self.forearm**2) / (2 * self.upper_arm * target_distance)
        cos_shoulder = max(-1, min(1, cos_shoulder))
        
        angle_to_target = math.atan2(dz, horizontal_distance)
        shoulder_angle = angle_to_target - math.acos(cos_shoulder)
        
        cos_elbow = (self.upper_arm**2 + self.forearm**2 - target_distance**2) / (2 * self.upper_arm * self.forearm)
        cos_elbow = max(-1, min(1, cos_elbow))
        elbow_angle = math.pi - math.acos(cos_elbow)
        
        joints = base_joints.copy()
        joints[0] = target_pan
        joints[1] = shoulder_angle
        joints[2] = elbow_angle
        
        return joints
        
    def joints_to_wrist3_position(self, joints):
        """
        Forward kinematics: convert joint positions to wrist3 position.
        Input:
        - joints: Joint positions (base, shoulder, elbow, wrist1, wrist2, wrist3): angles in radians
        Output:
        - (wrist3_x, wrist3_y, wrist3_z): Wrist3 position in "robot base frame"
        """
        q1, q2, q3 = joints[0], joints[1], joints[2]
        
        c1, s1 = math.cos(q1), math.sin(q1)
        
        # Position after upper arm
        upper_end_x = self.upper_arm * math.cos(q2) * c1
        upper_end_y = self.shoulder_offset + self.upper_arm * math.cos(q2) * s1
        upper_end_z = self.base_height + self.upper_arm * math.sin(q2)
        
        # Position after forearm
        forearm_angle = q2 + q3
        end_x = upper_end_x + self.forearm * math.cos(forearm_angle) * c1
        end_y = upper_end_y + self.forearm * math.cos(forearm_angle) * s1
        end_z = upper_end_z + self.forearm * math.sin(forearm_angle)
        
        return (end_x, end_y, end_z)
    
    def joints_to_tool_flange_position(self, joints):
        """
        Convert joint positions to tool_flange position (tool0 frame).
        Input:
        - joints: Joint positions (base, shoulder, elbow, wrist1, wrist2, wrist3): angles in radians
        Output:
        - (tool_flange_x, tool_flange_y, tool_flange_z): Tool_flange position in "robot base frame"
        """
        # First get wrist_3 position (end-effector)
        wrist3_pos = self.joints_to_wrist3_position(joints)
        
        # TODO: HARDCODE REMOVAL - UR5e tool_flange offset should be in robot specs
        # UR5e tool_flange is 82.5mm from wrist_3 along the Z-axis
        # With current joint configuration, tool_flange extends toward canvas
        tool_flange_offset = 0.0825  # HARDCODE: UR5e spec - 82.5mm
        
        # Calculate tool_flange position
        # For UR5e, tool_flange extends along wrist_3 Z-axis
        # Joint 4 (wrist_2) affects the tool orientation
        q4 = joints[4]  # wrist_2_joint
        q5 = joints[5]  # wrist_3_joint
        
        # Tool_flange offset in base frame coordinates
        # Simplified: assume tool points in same direction as wrist_3
        tool_flange_x = wrist3_pos[0]
        tool_flange_y = wrist3_pos[1] 
        tool_flange_z = wrist3_pos[2] - tool_flange_offset  # Tool_flange is below wrist_3
        
        return (tool_flange_x, tool_flange_y, tool_flange_z)
    
    def joints_to_pen_tip_position(self, joints):
        """
        Convert joint positions to actual pen tip position.
        input: joint positions (list) in 
        output: (x, y, z) coordinates of pen tip in robot frame
        """
        # First get tool_flange position
        tool_flange_pos = self.joints_to_tool_flange_position(joints)
        
        total_pen_extension = self.pen_length    

        # Calculate pen tip position
        tip_x = tool_flange_pos[0]
        tip_y = tool_flange_pos[1]
        tip_z = tool_flange_pos[2] - total_pen_extension  # tool_flangeからさらに下方向
        
        return (tip_x, tip_y, tip_z)
        
    def robot_to_pixel_coords(self, robot_x, robot_y):
        """
        Convert robot coordinates back to pixel coordinates.
        Input:
        - robot_x: X coordinate in "robot base frame"
        - robot_y: Y coordinate in "robot base frame"
        Output:
        - (pixel_x, pixel_y): Pixel coordinates in "pixel frame"
        """
        # Use same scale for both X and Y to maintain circle proportions
        scale = self.canvas_size / self.pixel_width
        
        # Transform from robot to canvas coordinate system
        canvas_x = robot_x - self.canvas_position[0]
        canvas_y = robot_y - self.canvas_position[1]
        
        # Convert canvas coordinates to pixel coordinates
        pixel_x = canvas_x / scale + self.pixel_width / 2
        pixel_y = canvas_y / scale + self.pixel_height / 2
        
        return pixel_x, pixel_y
